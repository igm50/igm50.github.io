{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"nodes":[{"frontmatter":{"date":"2021-08-01T00:00:00.000Z","title":"Gatsby で雑にマークダウン形式ブログを作る"},"html":"<h1>Gatsby で雑にマークダウン形式ブログを作る</h1>\n<p>「そうだ、自作ブログを作ろう。」<br>\n「どうせなら Qiita の記事をそのままブログに載せられるようにしたい。」<br>\n「もっというと、マークダウン形式のファイルをそのままブログに突っ込めるようにしたい。」<br>\n「でも面倒なことはしたくない。サーバーすら立てたくない」</p>\n<p>こんなわがままでもブログが作れてしまいます。<br>\nそう、Gatsby ならね。</p>\n<h2>前準備</h2>\n<p>npm がインストールされている前提で進めます。<br>\nまずは Gatsby のプロジェクトを作成しましょう<br>\n<a href=\"https://www.gatsbyjs.com/docs/tutorial/part-0/#gatsby-cli\">公式のチュートリアル</a>を見つつ、コマンドをぽちぽち叩いていきましょう。</p>\n<pre><code class=\"language-terminal\">npm install -g gatsby-cli\ngatsby new {任意のプロジェクト名}\n</code></pre>\n<p>これで完了です。早い。<br>\n生成されたディレクトリに移動し、<code>npm run develop</code>を実行することで Gatsby のデフォルトページが閲覧できます。<br>\nTypeScript を使いたい場合は<code>src/pages</code>ディレクトリ中の<code>js</code>ファイルの拡張子を<code>tsx</code>に変えましょう。もともと TypeScript での開発も想定されているようで、これだけで機能します。すごい。</p>\n<h2>マークダウンファイルのパース</h2>\n<p>下準備はできたので、早速本題に入りましょう。<br>\nマークダウンをパースするためには<a href=\"https://www.gatsbyjs.com/plugins/gatsby-transformer-remark/\">gatsby-transformer-remark</a>を使います。<br>\n<code>npm install gatsby-transformer-remark</code>でインストールし、<code>gatsby-config.js</code>に設定を加えましょう。</p>\n<pre><code class=\"language-javascript:gatsby-config.js\">  plugins: [\n    `gatsby-transformer-remark`,\n  ],\n</code></pre>\n<p>プラグイン項目に記述を追加するだけで動作してくれます。</p>\n<p>次に、実際に読み込みたいマークダウンファイルを追加します。<br>\nプロジェクトのルートディレクトリ配下ならどこでもいいのですが、今回は<code>src/markdown</code>配下に追加することとします。<br>\n適当に記述したマークダウンファイルを配置できたら、再び<code>gatsby-config.js</code>に記述を追加しましょう。</p>\n<pre><code class=\"language-javascript:gatsby-config.js\">  plugins: [\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `markdown`,\n        path: `${__dirname}/src/markdown`,\n      },\n    },\n  ]\n</code></pre>\n<p>こちらの設定はマークダウンファイルを Gatsby のエコシステムで認識できるようにするためのものです。</p>\n<p>ここまで設定できたら、一度ローカル環境で起動し、<code>http://localhost:8000/___graphql</code>にアクセスしてみましょう。<br>\nGatsby では GraphQL を採用しており、様々な情報を GraphQL 経由で取得することができます。<br>\n今回追加したマークダウンファイルについても同様で、上記の設定を追加することで GraphQL から取得できようになっています。<br>\n下記のクエリを投げてみましょう。</p>\n<pre><code class=\"language-graphql\">query MyQuery {\n  allMarkdownRemark {\n    nodes {\n      html\n    }\n  }\n}\n</code></pre>\n<p>問題がなければ、先ほど追加したマークダウンファイルが HTML 形式で取得できているはずです。</p>\n<h2>Gatsby への追加</h2>\n<p>では、上記で取得できた HTML を Gatsby に追加していきましょう。<br>\n先ほど行った修正により、マークダウンファイルを HTML 形式で GraphQL 経由で取得することができるようになっています。<br>\nGatsby ではこの GraphQL を利用することができます。</p>\n<pre><code class=\"language-javascript:index.js\">import * as React from \"react\"\nimport { graphql } from \"gatsby\"\n\nimport Layout from \"../components/layout\"\n\nexport const query = graphql`\n  query MyQuery {\n    allMarkdownRemark {\n      nodes {\n        id\n        html\n      }\n    }\n  }\n`\n\nconst IndexPage = ({data}) => (\n  &#x3C;Layout>\n    &#x3C;div dangerouslySetInnerHTML={{__html: data.allMarkdownRemark.nodes[0].html}}>&#x3C;/div>\n  &#x3C;/Layout>\n)\n\nexport default IndexPage\n</code></pre>\n<p>GraphQL で取得したデータは、引数に<code>data</code>を指定することで読み込むことができます。簡単ですね。<br>\nHTML 形式で取得しているので、あとはそのまま出力するように突っ込むだけです。</p>\n<p>今回利用している<code>dangerouslySetInnerHTML</code>は React で提供されている属性です。<br>\nわざわざ<code>dangerously</code>としているのは XSS の危険性があるためです。詳しいことは<a href=\"https://ja.reactjs.org/docs/dom-elements.html\">公式のドキュメント</a>を参照してください。</p>\n<p>あとは<code>npm run develop</code>などで結果を確認するだけです。<br>\nうまく設定できていれば、マークダウンファイルの中身がちゃんと表示されているはずです。</p>\n<h2>おわりに</h2>\n<p>というわけで、Gatsby なら簡単にマークダウン形式のブログが作れるよ、という記事でした。<br>\n私は上記に加え Github Pages を利用することで、簡単な俺俺ブログにしています。<br>\n厳密には Qiita では改行コードがそのまま改行として扱われますが、今回作成したものではちゃんとスペースを 2 つ並べなければ改行されません。<br>\nとはいえあとはほぼそのままで動きますし、改行させるだけなら大した手間ではないでしょう。<br>\nGatsby は便利だなぁ。</p>"},{"frontmatter":{"date":"2021-08-09T00:00:00.000Z","title":"Rustでズンドコキヨシ"},"html":"<h1>Rust でズンドコキヨシ</h1>\n<p>先駆者様: <a href=\"https://qiita.com/tatsuya6502/items/aea38af7fcfb912c3aff\">ズンドコキヨシ with Rust</a></p>\n<h2>TL;DR</h2>\n<pre><code class=\"language-console\">$ ./target/debug/zundoko-cli\nズンズンドコドコドコズンズンズンズンドコ\nキ・ヨ・シ！\n</code></pre>\n<h2>コード</h2>\n<pre><code class=\"language-rust:main.rs\">use rand;\n\nfn main() {\n    println!(\"{}\", ZundokoKiyoshi::build_str());\n}\n\nenum Zundoko {\n    Zun,\n    Doko,\n}\n\nimpl ToString for Zundoko {\n    fn to_string(&#x26;self) -> String {\n        match self {\n            Self::Zun => \"ズン\".to_string(),\n            Self::Doko => \"ドコ\".to_string(),\n        }\n    }\n}\n\nstruct ZundokoKiyoshi;\n\nimpl ZundokoKiyoshi {\n    fn zundoko() -> Zundoko {\n        match rand::random() {\n            true => Zundoko::Zun,\n            false => Zundoko::Doko,\n        }\n    }\n\n    fn kiyoshi() -> String {\n        \"\\nキ・ヨ・シ！\".to_string()\n    }\n\n    fn build_str() -> String {\n        let mut result = String::new();\n        let mut cnt = 0;\n\n        loop {\n            let zundoko = Self::zundoko();\n            result += &#x26;zundoko.to_string();\n\n            match zundoko {\n                Zundoko::Zun => cnt += 1,\n                Zundoko::Doko if cnt &#x3C; 4 => cnt = 0,\n                _ => {\n                    result += &#x26;Self::kiyoshi();\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n}\n</code></pre>\n<h2>終わりに</h2>\n<p>Rust は触っていないとすぐお作法を忘れてしまいますね。\nズンドコキヨシはリハビリにはちょうどよかったです。</p>\n<p>今回はちょっと冗長なコードで記述させていただきました。\nでも先駆者様はすごくシンプルなコードで記述できているんですよね。見習いたいです。</p>"},{"frontmatter":{"date":"2021-10-09T00:00:00.000Z","title":"Python のシンプルな Web フレームワーク「FastAPI」の触りだけ触れてみる"},"html":"<h1>Python のシンプルな Web フレームワーク「FastAPI」の触りだけ触れてみる</h1>\n<p>最近思うところがあって Python の勉強を始めました。<br>\nでも機械学習はあまり興味がないし、とっつきやすい Web フレームワークでできるだけシンプルなやつないかなーと探したところ、ひっかかったのがこの FastAPI でした。<br>\nというわけで、FastAPI を使ってウェブリクエスト経由で DB のレコードを取得するところまでやってみたいと思います。</p>\n<h2>環境構築</h2>\n<p>まずは環境を作りましょう。<br>\nローカル汚したくないマンなのでとりあえず仮想環境で作りましょう。<br>\nまずは Dockerfile から。</p>\n<pre><code class=\"language-dockerfile:docker/app/dockerfile\">FROM python:3.9.7-alpine\n\nRUN apk update \\\n  &#x26;&#x26; apk add build-base mariadb-dev libressl-dev musl-dev libffi-dev \\\n  &#x26;&#x26; pip install autopep8 fastapi uvicorn[standard] pymysql mysqlclient cryptography\n\nEXPOSE 8000\n</code></pre>\n<p>続いて Docker Compose の設定に移りましょう。</p>\n<pre><code class=\"language-yaml:docker/docker-compose.yml\">services:\n  app:\n    build: ./app\n    volumes:\n      - ../src:/usr/app\n    ports:\n      - \"8000:8000\"\n    tty: true\n  database:\n    # 下記URLから world データベースの SQL を取得して docker/database に格納する\n    # https://dev.mysql.com/doc/index-other.html\n    image: mysql:8.0.26\n    volumes:\n      - ./database:/docker-entrypoint-initdb.d\n    restart: always\n    ports:\n      - \"3306:3306\"\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n</code></pre>\n<p>シンプルな AP サーバーと DB サーバーの構成ですね。<br>\nとりあえずお試しで動かす分には十分でしょう。</p>\n<h3>Uvicorn とは</h3>\n<p>さて、今回導入した<code>Uvicorn</code>とは ASGI サーバーの一つらしいですが、こちらはちょっと耳慣れない単語です (いわゆる Pythonista には聞き慣れた単語かもしれません)。<br>\n利用する前にサクッと調べておきましょう。</p>\n<blockquote>\n<p>ASGI (Asynchronous Server Gateway Interface) is a spiritual successor to WSGI, intended to provide a standard interface between async-capable Python web servers, frameworks, and applications.</p>\n</blockquote>\n<blockquote>\n<p>(Google 翻訳) ASGI（Asynchronous Server Gateway Interface）は、WSGI の精神的な後継者であり、非同期対応の Python Web サーバー、フレームワーク、およびアプリケーション間の標準インターフェイスを提供することを目的としています。</p>\n</blockquote>\n<p>出典: <a href=\"https://asgi.readthedocs.io/en/latest/\">ASGI Documentation</a></p>\n<p>なるほど、元となる<code>WSGI</code>というものがあり、その後継となる立ち位置を自負しているんですね。<br>\nおおよそのことは上記でわかりましたが、一応 WSGI についても簡単に調べておきましょう。</p>\n<blockquote>\n<p>This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.</p>\n</blockquote>\n<blockquote>\n<p>(Google 翻訳) このドキュメントでは、さまざまな Web サーバー間で Web アプリケーションの移植性を促進するために、Web サーバーと PythonWeb アプリケーションまたはフレームワークの間で提案されている標準インターフェイスを指定します。</p>\n</blockquote>\n<p>出典: <a href=\"https://www.python.org/dev/peps/pep-3333/\">PEP 3333 -- Python Web Server Gateway Interface v1.0.1</a></p>\n<p>WSGI とは Python の Web アプリ(フレームワーク)のインターフェースを定義したもののようです。あくまで定義なんですね。<br>\nつまりまとめると、Python の Web アプリでは WSGI というインターフェースが定義されており、それをより発展させた ASGI というインターフェース定義が存在し、さらにその実装として Uvicorn が存在する、ということでしょうか。<br>\nものすごく乱暴に言うと、Java でいう Tomcat みたいな存在でしょうか?</p>\n<p>ともあれ、これで Uvicorn の立ち位置についてはおおよそわかったかと思います。</p>\n<h2>実装</h2>\n<p>と言うわけで実際にコードを書いてみましょう。<br>\n今回は MySQL のサンプルデータを利用し、city テーブルのデータを取得できることを目標とします。<br>\n\b<a href=\"https://fastapi.tiangolo.com/ja/tutorial/\">公式のチュートリアル</a>が簡単にまとめられているので、そちらを参考にするといいでしょう。</p>\n<p>そして出来上がったものがこちらになります。</p>\n<pre><code class=\"language-python:src/main.py\">from typing import List\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nfrom database import Database\nfrom model import City\n\napp = FastAPI()\ndb = Database()\n\n\nclass CityOut(BaseModel):\n    id: int\n    name: str\n    country_code: str\n    district: str\n    population: int\n\n    @classmethod\n    def fromCities(cls, cities: List[City]) -> str:\n        return [cls.fromCity(city) for city in cities]\n\n    @staticmethod\n    def fromCity(city: City) -> str:\n        return {\"id\": city.id, \"name\": city.name, \"country_code\": city.country_code, \"district\": city.district, \"population\": city.population}\n\n\n@app.get(\"/city\", response_model=List[CityOut])\ndef read_cities(limit: int = 10):\n    cities = db.read_cities(limit)\n    return CityOut.fromCities(cities)\n\n\n@app.get(\"/city/{city_id}\", response_model=CityOut)\ndef read_city(city_id: int):\n    city = db.read_city(city_id)\n    return CityOut.fromCity(city)\n</code></pre>\n<p>上記の<code>main.py</code>以外にも<code>model.py</code>と<code>database.py</code>を作成しましたが、今回はあまり関係ないので載せていないです。<br>\n<a href=\"https://github.com/igm50/fastapi-sample\">GitHub のリポジトリ</a>に載せてあるので、必要な方はそちらをどうぞ。</p>\n<p>本題のコードを見てみますと、実にシンプルに作成できていることがわかります。<br>\n大事なところを見ていきましょう。</p>\n<pre><code class=\"language-python\">@app.get(\"/city\", response_model=List[CityOut])\ndef read_cities(limit: int = 10):\n    cities = db.read_cities(limit)\n    return CityOut.fromCities(cities)\n</code></pre>\n<p>こちらは city の一覧を取得するエンドポイントですね。<br>\n<code>@app.get</code>で HTTP メソッド、URL、レスポンスのデータ構造を定義しています。いちいち説明しなくてもよくある形なのでパッとわかるかと思います。<br>\n引数の<code>limit</code>はクエリパラメータとして取得可能です。デフォルト値も設定可能で、今回は<code>10</code>としています。</p>\n<pre><code class=\"language-python\">@app.get(\"/city/{city_id}\", response_model=CityOut)\ndef read_city(city_id: int):\n    city = db.read_city(city_id)\n    return CityOut.fromCity(city)\n</code></pre>\n<p>こちらは指定した ID を持つ city を取得するエンドポイントです。<br>\n今度の引数<code>city_id</code>は URL から取得しています。こちらもよくある形ですね。</p>\n<h2>起動</h2>\n<p>コードが書けたので今度は動かしてみましょう。<br>\nUvicorn にアプリを載せる形で起動します。</p>\n<pre><code class=\"language-terminal\">$ uvicorn main:app --reload\n</code></pre>\n<p>正常に動作すれば OK です。</p>\n<h3>API ドキュメント</h3>\n<p>さて、ここでお伝えしたいのが FastAPI の標準機能の一つである API ドキュメントの自動生成です。<br>\n通常 FastAPI は 8000 ポートで起動されます (仮想環境上で動かしているので関係ないと言えば関係ないのですが)。<br>\n<code>http://localhost:8000/docs</code>にアクセスしてみましょう。</p>\n<!-- ![swagger](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/213374/e0ac7135-1b10-fe64-2010-5d70901fd637.png) -->\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e70341eca420d7d97232894cb1860cf3/20f38/3-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA0ElEQVQoz6WRTXLDIAxGuf9JeoAeIsu2q+6aqdOSsY1bwBIYBF8G2guEaOaNpM0b/ah5XnH50vg4T7iYN5R6oEWtdQhlPcNaj5wSpKSmwiOhls1i2VxvSgWk1CGyFOQsUM/vgqfXjPPVQ2+MxQsMlbvZqGJ2Cerlu+D0WTD/MFbL+KUEH+udlJ4tC1RkgqSA/0/83bCOISJQxIzVGDAzWk1EQ+xEiDFChRBhjOlYa7Hv+zDNpZp9miZorR8Seu8RQoBKKcE511c+jqOPPUpz3QA/6wq/OPnKrwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"swagger\"\n        title=\"swagger\"\n        src=\"/static/e70341eca420d7d97232894cb1860cf3/0a47e/3-1.png\"\n        srcset=\"/static/e70341eca420d7d97232894cb1860cf3/8a4e8/3-1.png 150w,\n/static/e70341eca420d7d97232894cb1860cf3/5a46d/3-1.png 300w,\n/static/e70341eca420d7d97232894cb1860cf3/0a47e/3-1.png 600w,\n/static/e70341eca420d7d97232894cb1860cf3/1cfc2/3-1.png 900w,\n/static/e70341eca420d7d97232894cb1860cf3/c1b63/3-1.png 1200w,\n/static/e70341eca420d7d97232894cb1860cf3/20f38/3-1.png 2818w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>出ました。<br>\nもはや Swagger は REST-API 開発のデファクトスタンダードと言っても過言ではないかと思いますが、FastAPI は Swagger UI のページをデフォルトで生成&#x26;提供してくれます。<br>\nSwagger UI が提供されているのであれば、エンドポイントやリクエスト、レスポンスの形式を容易に確認できるほか、ブラウザ上でリクエストを送信して試すこともできます。<br>\nこのリクエスト、レスポンス形式はコード上で定義されているため、コードを更新するたびに最新化されます。<br>\nドキュメントの管理は重要であると同時に面倒なものでもありますが、フレームワーク側で全部やってくれるのであればそのメリットだけ享受することができます。<br>\n本機能が開発速度の向上に大きく貢献するのは想像に難くないですね。</p>\n<p>このように、FastAPI は軽量なフレームワークというだけでなく、モダンな機能も備えています。<br>\nまだ触りだけしか触れられていないので、もっと使い込めばいろいろと便利な機能が見つかりそうでワクワクしますね。</p>\n<h2>終わりに</h2>\n<p>というわけで、FastAPI はすごいなぁという記事でした。<br>\nフレームワークはそう簡単に乗り換えるというわけにはいきませんが、こういう便利なツールはどんどん使っていきたいですね。</p>\n<h2>参考</h2>\n<p>\b<a href=\"https://fastapi.tiangolo.com/ja/\">FastAPI</a><br>\n<a href=\"https://qiita.com/itosho/items/9565c6ad2ffc24c09364\">Git のコミットメッセージの書き方</a><br>\n<a href=\"https://qiita.com/motoki1990/items/376fc1d1f3d59c960f5c\">Python クラスについて</a><br>\n<a href=\"https://qiita.com/motoki1990/items/d06fc7559546a8471392\">Python 配列のループ処理</a><br>\n<a href=\"https://stackoverflow.com/questions/893333/multiple-variables-in-a-with-statement\">Multiple variables in a 'with' statement?</a><br>\n<a href=\"https://stackoverflow.com/questions/35736598/cannot-pip-install-cryptography-in-docker-alpine-linux-3-3-with-openssl-1-0-2g\">Cannot \"pip install cryptography\" in Docker Alpine Linux 3.3 with OpenSSL 1.0.2g and Python 2.7</a><br>\n<a href=\"https://qiita.com/itsu_dev/items/a17b515fdfa92ca912f1\">Alpine Linux で pip install mysqlclient するのにハマった時のメモ</a></p>"}]}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}